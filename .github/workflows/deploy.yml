# =============================================================================
# DEPLOY.YML - GitHub Actions Workflow pour Fode-DevOps Infrastructure (CORRIG√â)
# =============================================================================

name: üöÄ Fode-DevOps Infrastructure Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'terraform/**'
      - 'ansible/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'ansible/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action √† effectuer'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
          - create-backend

env:
  TF_VERSION: '1.6.0'
  ANSIBLE_VERSION: '2.15'
  AWS_DEFAULT_REGION: 'us-east-1'
  BACKEND_BUCKET: 'fode-devops-terraform-state'
  DYNAMODB_TABLE: 'fode-devops-terraform-locks'

jobs:
  # =============================================================================
  # JOB 0: CR√âATION DU BACKEND S3 (SI N√âCESSAIRE)
  # =============================================================================
  create-backend:
    name: üèóÔ∏è Cr√©er Backend S3
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.action == 'create-backend'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}
        
    - name: üèóÔ∏è Create S3 Backend Infrastructure
      run: |
        # Cr√©er le bucket S3 pour l'√©tat Terraform
        echo "üì¶ Cr√©ation du bucket S3: $BACKEND_BUCKET"
        if ! aws s3 ls s3://$BACKEND_BUCKET 2>/dev/null; then
          aws s3 mb s3://$BACKEND_BUCKET --region $AWS_DEFAULT_REGION
          echo "‚úÖ Bucket S3 cr√©√©"
        else
          echo "‚úÖ Bucket S3 existe d√©j√†"
        fi
        
        # Activer le versioning
        aws s3api put-bucket-versioning \
          --bucket $BACKEND_BUCKET \
          --versioning-configuration Status=Enabled
        
        # Activer le chiffrement
        aws s3api put-bucket-encryption \
          --bucket $BACKEND_BUCKET \
          --server-side-encryption-configuration '{
            "Rules": [
              {
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }
            ]
          }'
        
        # Bloquer l'acc√®s public
        aws s3api put-public-access-block \
          --bucket $BACKEND_BUCKET \
          --public-access-block-configuration \
          BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
        
        # Cr√©er la table DynamoDB
        echo "üîê Cr√©ation de la table DynamoDB: $DYNAMODB_TABLE"
        if ! aws dynamodb describe-table --table-name $DYNAMODB_TABLE --region $AWS_DEFAULT_REGION 2>/dev/null; then
          aws dynamodb create-table \
            --table-name $DYNAMODB_TABLE \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
            --region $AWS_DEFAULT_REGION \
            --tags Key=Name,Value="Terraform State Lock" Key=Project,Value="Fode-DevOps"
          
          # Attendre que la table soit active
          aws dynamodb wait table-exists --table-name $DYNAMODB_TABLE --region $AWS_DEFAULT_REGION
          echo "‚úÖ Table DynamoDB cr√©√©e"
        else
          echo "‚úÖ Table DynamoDB existe d√©j√†"
        fi
        
        echo "üéâ Backend infrastructure cr√©√©e avec succ√®s!"

  # =============================================================================
  # JOB 1: V√âRIFICATION DU BACKEND
  # =============================================================================
  check-backend:
    name: üîç V√©rifier Backend
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'create-backend'
    outputs:
      backend_exists: ${{ steps.check.outputs.backend_exists }}
    
    steps:
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}
        
    - name: üîç Check Backend Existence
      id: check
      run: |
        echo "V√©rification de l'existence du backend..."
        
        # V√©rifier le bucket S3
        if aws s3 ls s3://$BACKEND_BUCKET 2>/dev/null; then
          echo "‚úÖ Bucket S3 existe"
          S3_EXISTS=true
        else
          echo "‚ùå Bucket S3 n'existe pas"
          S3_EXISTS=false
        fi
        
        # V√©rifier la table DynamoDB
        if aws dynamodb describe-table --table-name $DYNAMODB_TABLE --region $AWS_DEFAULT_REGION 2>/dev/null; then
          echo "‚úÖ Table DynamoDB existe"
          DYNAMODB_EXISTS=true
        else
          echo "‚ùå Table DynamoDB n'existe pas"
          DYNAMODB_EXISTS=false
        fi
        
        if [ "$S3_EXISTS" = true ] && [ "$DYNAMODB_EXISTS" = true ]; then
          echo "backend_exists=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend infrastructure existe"
        else
          echo "backend_exists=false" >> $GITHUB_OUTPUT
          echo "‚ùå Backend infrastructure manquante"
          echo ""
          echo "Pour cr√©er le backend, ex√©cutez:"
          echo "gh workflow run deploy.yml --field action=create-backend"
          exit 1
        fi

  # =============================================================================
  # JOB 2: VALIDATION ET S√âCURIT√â
  # =============================================================================
  validation:
    name: üîç Validation et S√©curit√©
    runs-on: ubuntu-latest
    needs: check-backend
    if: needs.check-backend.outputs.backend_exists == 'true'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        
    - name: üîë Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ~/.ssh/id_rsa.pub
        chmod 600 ~/.ssh/id_rsa.pub
        # Cr√©er le r√©pertoire keys dans terraform
        mkdir -p ./terraform/keys
        cp ~/.ssh/id_rsa.pub ./terraform/keys/
        
    - name: üîç Terraform Format et Auto-correction
      working-directory: ./terraform
      run: |
        # Formater automatiquement tous les fichiers
        terraform fmt -recursive
        
        # V√©rifier s'il y a des changements apr√®s formatage
        if ! git diff --quiet; then
          echo "üìù Fichiers format√©s automatiquement"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Auto-Format"
          git add .
          git commit -m "üîß Auto-format Terraform files [skip ci]"
          git push
          echo "‚úÖ Changements de formatage committ√©s automatiquement"
        else
          echo "‚úÖ Tous les fichiers sont d√©j√† correctement format√©s"
        fi
      
    - name: ‚úÖ Terraform Validate
      working-directory: ./terraform
      run: |
        terraform init -backend=false
        terraform validate
        
    - name: üîí Security Scan avec Checkov
      uses: bridgecrewio/checkov-action@master
      with:
        directory: ./terraform
        framework: terraform
        output_format: cli
      continue-on-error: true

   # =============================================================================
  # JOB 3: TERRAFORM PLAN
  # =============================================================================
  terraform-plan:
    name: üìã Terraform Plan
    runs-on: ubuntu-latest
    needs: [check-backend, validation]
    if: |
      always() && 
      (needs.check-backend.result == 'success' || needs.check-backend.result == 'skipped') &&
      needs.validation.result == 'success' &&
      github.event.inputs.action != 'create-backend' &&
      github.event.inputs.action != 'destroy'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        
    - name: üîë Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ~/.ssh/id_rsa.pub
        chmod 600 ~/.ssh/id_rsa.pub
        mkdir -p ./terraform/keys
        cp ~/.ssh/id_rsa.pub ./terraform/keys/
        
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}
        
    - name: üì¶ Terraform Init
      working-directory: ./terraform
      run: terraform init
      
    - name: üìã Terraform Plan
      working-directory: ./terraform
      run: |
        # D√©terminer l'environnement bas√© sur la branche ou l'input
        if [ "${{ github.event.inputs.action }}" != "" ]; then
          ENVIRONMENT="prod"  # Chang√© de "production" √† "prod"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          ENVIRONMENT="prod"  # Chang√© de "production" √† "prod"
        elif [ "${{ github.ref_name }}" = "staging" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="dev"   # Par d√©faut pour les autres branches
        fi
        
        echo "üéØ Planification pour l'environnement: $ENVIRONMENT"
        
        terraform plan -out=tfplan \
          -var="project_name=fode-devops" \
          -var="environment=$ENVIRONMENT" \
          -var="aws_region=${{ env.AWS_DEFAULT_REGION }}" \
          -var="instance_type=t2.micro"
          
    - name: üíæ Save Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: ./terraform/tfplan
        retention-days: 30

  # =============================================================================
  # JOB 4: TERRAFORM APPLY
  # =============================================================================
  terraform-apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    needs: [check-backend, validation, terraform-plan]
    if: |
      always() && 
      (needs.check-backend.result == 'success' || needs.check-backend.result == 'skipped') &&
      needs.validation.result == 'success' &&
      needs.terraform-plan.result == 'success' &&
      (
        (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
        github.event.inputs.action == 'apply'
      )
    environment: production
    outputs:
      load_balancer_dns: ${{ steps.terraform-outputs.outputs.load_balancer_dns }}
      instance_id: ${{ steps.terraform-outputs.outputs.instance_id }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
        
    - name: üîë Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ~/.ssh/id_rsa.pub
        chmod 600 ~/.ssh/id_rsa.pub
        mkdir -p ./terraform/keys
        cp ~/.ssh/id_rsa.pub ./terraform/keys/
        
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}
        
    - name: üì¶ Terraform Init
      working-directory: ./terraform
      run: terraform init
      
    - name: üöÄ Terraform Apply
      working-directory: ./terraform
      run: |
        # D√©terminer l'environnement (m√™me logique que terraform-plan)
        if [ "${{ github.event.inputs.action }}" != "" ]; then
          ENVIRONMENT="prod"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          ENVIRONMENT="prod"
        elif [ "${{ github.ref_name }}" = "staging" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="dev"
        fi
        
        echo "üöÄ D√©ploiement pour l'environnement: $ENVIRONMENT"
        
        terraform apply -auto-approve \
          -var="project_name=fode-devops" \
          -var="environment=$ENVIRONMENT" \
          -var="aws_region=${{ env.AWS_DEFAULT_REGION }}" \
          -var="instance_type=t2.micro"
          
    - name: üì§ Export Terraform Outputs
      id: terraform-outputs
      working-directory: ./terraform
      run: |
        # V√©rifier si les outputs existent avant de les extraire
        if terraform output load_balancer_dns >/dev/null 2>&1; then
          LB_DNS=$(terraform output -raw load_balancer_dns)
          echo "load_balancer_dns=$LB_DNS" >> $GITHUB_OUTPUT
        else
          echo "load_balancer_dns=non-disponible" >> $GITHUB_OUTPUT
        fi
        
        if terraform output instance_id >/dev/null 2>&1; then
          INSTANCE_ID=$(terraform output -raw instance_id)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        else
          echo "instance_id=non-disponible" >> $GITHUB_OUTPUT
        fi
        
    - name: üìä Create Deployment Summary
      working-directory: ./terraform
      run: |
        # D√©terminer l'environnement pour l'affichage
        if [ "${{ github.event.inputs.action }}" != "" ]; then
          ENVIRONMENT="prod"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          ENVIRONMENT="prod"
        elif [ "${{ github.ref_name }}" = "staging" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="dev"
        fi
        
        echo "## üöÄ D√©ploiement Fode-DevOps R√©ussi!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Informations du d√©ploiement:" >> $GITHUB_STEP_SUMMARY
        echo "- **Instance ID:** ${{ steps.terraform-outputs.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Load Balancer DNS:** ${{ steps.terraform-outputs.outputs.load_balancer_dns }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.terraform-outputs.outputs.load_balancer_dns }}" != "non-disponible" ]; then
          echo "- **URL:** http://${{ steps.terraform-outputs.outputs.load_balancer_dns }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "- **R√©gion:** ${{ env.AWS_DEFAULT_REGION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Environnement:** $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # JOB 5: TESTS POST-D√âPLOIEMENT
  # =============================================================================
  post-deployment-tests:
    name: üß™ Tests Post-D√©ploiement
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: |
      always() && 
      needs.terraform-apply.result == 'success' &&
      needs.terraform-apply.outputs.load_balancer_dns != 'non-disponible'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
        
    - name: üß™ Test Load Balancer
      run: |
        # R√©cup√©rer le DNS du Load Balancer
        LB_DNS="${{ needs.terraform-apply.outputs.load_balancer_dns }}"
        
        if [ "$LB_DNS" = "non-disponible" ] || [ -z "$LB_DNS" ]; then
          echo "‚ö†Ô∏è Load Balancer DNS non disponible, skip des tests"
          exit 0
        fi
        
        # Attendre que le Load Balancer soit pr√™t
        echo "‚è≥ Attente du d√©marrage du Load Balancer..."
        sleep 120
        
        # Test de connectivit√© HTTP
        echo "üåê Test de connectivit√© HTTP via Load Balancer..."
        for i in {1..15}; do
          if curl -f -s http://$LB_DNS; then
            echo "‚úÖ Load Balancer accessible!"
            break
          else
            echo "‚è≥ Tentative $i/15..."
            sleep 20
          fi
        done
        
        # Test de contenu
        echo "üìÑ Test du contenu..."
        CONTENT=$(curl -s http://$LB_DNS || echo "")
        if echo "$CONTENT" | grep -q "Fode-DevOps\|Welcome\|nginx\|Apache"; then
          echo "‚úÖ Contenu correct d√©tect√©!"
        else
          echo "‚ö†Ô∏è Contenu inattendu, mais service accessible"
        fi

  # =============================================================================
  # JOB 6: TERRAFORM DESTROY
  # =============================================================================
  terraform-destroy:
    name: üí• Terraform Destroy
    runs-on: ubuntu-latest
    needs: check-backend
    if: |
      always() && 
      (needs.check-backend.result == 'success' || needs.check-backend.result == 'skipped') &&
      github.event.inputs.action == 'destroy'
    environment: destruction
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        
    - name: üîë Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ~/.ssh/id_rsa.pub
        chmod 600 ~/.ssh/id_rsa.pub
        mkdir -p ./terraform/keys
        cp ~/.ssh/id_rsa.pub ./terraform/keys/
        
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}
        
    - name: üì¶ Terraform Init
      working-directory: ./terraform
      run: terraform init
      
    - name: üí• Terraform Destroy
      working-directory: ./terraform
      run: |
        terraform destroy -auto-approve \
          -var="project_name=fode-devops" \
          -var="environment=production" \
          -var="aws_region=${{ env.AWS_DEFAULT_REGION }}" \
          -var="instance_type=t2.micro"
          
    - name: üìä Destruction Summary
      run: |
        echo "## üí• Infrastructure Fode-DevOps D√©truite!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ‚ö†Ô∏è Toutes les ressources ont √©t√© supprim√©es" >> $GITHUB_STEP_SUMMARY
        echo "- **R√©gion:** ${{ env.AWS_DEFAULT_REGION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Projet:** fode-devops" >> $GITHUB_STEP_SUMMARY